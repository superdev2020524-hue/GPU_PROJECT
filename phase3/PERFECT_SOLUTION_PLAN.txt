================================================================================
PERFECT SOLUTION PLAN - SHIM FOR ALL PROCESSES
================================================================================

GOAL: Make the shim work perfectly for ALL processes via /etc/ld.so.preload
      while preventing VM breakage through aggressive safety measures.

================================================================================
WORKING DIRECTION
================================================================================

1. **RESTORE cuInit() IN CONSTRUCTOR** (required for early Ollama discovery)
   BUT make it SAFE with:
   - Process detection (skip or defer in critical system processes)
   - Timeout protection (prevent infinite hangs)
   - Error isolation (failures don't crash the process)
   - Non-blocking operations (don't block system initialization)
   - Graceful degradation (fallback if initialization fails)

2. **AGGRESSIVE SAFETY MEASURES:**
   - Detect system processes (systemd, init, sshd) and use minimal init
   - Use signal handlers to prevent hangs
   - Implement timeout mechanisms for all I/O operations
   - Add comprehensive error recovery
   - Use async-safe functions only in constructor
   - Prevent deadlocks with mutex timeouts

3. **ROBUST INITIALIZATION:**
   - Try cuInit() with timeout protection
   - If it fails or hangs, mark as "deferred" and let ensure_init() handle it
   - Don't block process startup
   - Log everything for debugging
   - Handle all edge cases

4. **RESEARCH-BASED IMPROVEMENTS:**
   - Study how other system-wide preload libraries work (libc, etc.)
   - Research constructor best practices for system libraries
   - Implement proven patterns from production libraries
   - Add comprehensive testing scenarios

================================================================================
IMPLEMENTATION STRATEGY
================================================================================

PHASE 1: RESTORE AND HARDEN CONSTRUCTOR
- Restore cuInit() call in constructor
- Add process detection (identify system processes)
- Add timeout protection (alarm() or timer)
- Add error isolation (try-catch equivalent)
- Add graceful degradation

PHASE 2: ENHANCE SAFETY MECHANISMS
- Implement signal-safe logging
- Add mutex timeout protection
- Add filesystem operation timeouts
- Add device access protection
- Add memory safety checks

PHASE 3: COMPREHENSIVE ERROR HANDLING
- Handle all possible failure modes
- Add recovery mechanisms
- Implement fallback strategies
- Add comprehensive logging
- Create diagnostic tools

PHASE 4: TESTING AND VALIDATION
- Test with system processes (systemd, sshd, etc.)
- Test with application processes (Ollama, etc.)
- Test failure scenarios
- Test timeout scenarios
- Validate no VM breakage

================================================================================
TECHNICAL APPROACH
================================================================================

1. **PROCESS DETECTION:**
   - Check process name (systemd, init, sshd, etc.)
   - Check parent process (systemd children)
   - Check process capabilities
   - Use this to determine initialization strategy

2. **TIMEOUT PROTECTION:**
   - Use alarm() for timeout (SIGALRM handler)
   - Or use timerfd for more control
   - Set reasonable timeout (e.g., 1 second)
   - If timeout, mark as deferred and continue

3. **ERROR ISOLATION:**
   - Wrap all operations in error handlers
   - Use setjmp/longjmp for error recovery
   - Never let constructor crash the process
   - Always have a fallback path

4. **NON-BLOCKING OPERATIONS:**
   - Use O_NONBLOCK for file operations
   - Use non-blocking I/O where possible
   - Don't wait for locks indefinitely
   - Don't block on network operations

5. **GRACEFUL DEGRADATION:**
   - If initialization fails, mark as "will retry later"
   - Let ensure_init() handle retry on first CUDA call
   - Don't prevent process from starting
   - Log the failure for debugging

================================================================================
RESEARCH AREAS
================================================================================

1. **System Library Best Practices:**
   - How do libc, libpthread handle initialization?
   - What patterns do production preload libraries use?
   - How do they handle system processes?

2. **Constructor Safety:**
   - What operations are safe in constructors?
   - How to handle errors in constructors?
   - How to prevent deadlocks in constructors?

3. **Timeout Mechanisms:**
   - Best practices for timeouts in constructors
   - Signal-safe timeout implementations
   - Non-blocking I/O patterns

4. **Error Recovery:**
   - Error handling in system libraries
   - Graceful degradation strategies
   - Recovery mechanisms for failed initialization

================================================================================
SUCCESS CRITERIA
================================================================================

✓ Shim loads in ALL processes without breaking them
✓ System processes (systemd, sshd) continue to work normally
✓ Application processes (Ollama) get early CUDA initialization
✓ No VM breakage or unresponsiveness
✓ Ollama successfully discovers GPU and uses GPU mode
✓ All error cases handled gracefully
✓ Comprehensive logging for debugging
✓ Production-ready robustness

================================================================================
NEXT STEPS
================================================================================

1. Research constructor safety patterns
2. Implement process detection
3. Add timeout protection to cuInit()
4. Add error isolation mechanisms
5. Test with system processes
6. Test with application processes
7. Validate no VM breakage
8. Deploy and monitor

================================================================================
