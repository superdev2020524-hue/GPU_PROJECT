================================================================================
                    SCHEDULER IMPLEMENTATION RECOMMENDATIONS
                    Phase 2-3: Initial Scheduler Version
================================================================================

Date: January 2026
Based on: Current system analysis and scheduling algorithm research

================================================================================
                            EXECUTIVE SUMMARY
================================================================================

RECOMMENDED APPROACH: Priority-Based Scheduling with Fairness Guarantees
----------------------------------------------------------------------------

Primary Recommendation: **Priority Aging with Time-Slice Quantum**
- Simple to implement and verify
- Prevents starvation (monopolization)
- Deterministic behavior
- Extensible for future features

Alternative Options:
1. Weighted Fair Queuing (WFQ) - More complex, better fairness
2. Round-Robin with Priority - Simplest, but may starve low priority
3. Deficit Round-Robin (DRR) - Good fairness, moderate complexity

================================================================================
                        CURRENT SYSTEM ANALYSIS
================================================================================

Strengths:
----------
‚úÖ Priority queue already implemented (insert_request, pop_request)
‚úÖ Two-pool architecture (A & B) working
‚úÖ Thread-safe operations (pthread mutexes)
‚úÖ Test mode for validation
‚úÖ Deterministic priority ordering (High > Medium > Low)

Gaps to Address:
----------------
‚è≥ No starvation prevention (low priority can wait indefinitely)
‚è≥ No time limits per request
‚è≥ No fairness tracking
‚è≥ No preemption capability
‚è≥ No per-VM resource accounting

Current Scheduling Logic:
-------------------------
1. Priority: High (2) > Medium (1) > Low (0) ‚úì
2. Tie-breaking: FIFO or Preferred VM ‚úì
3. Pool processing: Round-robin ‚úì
4. Execution: Non-preemptive (one job at a time) ‚úì

Problem: If high-priority requests keep arriving, low-priority may never execute.

================================================================================
                    RECOMMENDATION 1: PRIORITY AGING
                    ‚≠ê PRIMARY RECOMMENDATION
================================================================================

Algorithm: Priority Aging with Time-Slice Quantum
-------------------------------------------------

Concept:
--------
- Requests age while waiting in queue
- After waiting time threshold, priority increases
- Time-slice quantum prevents single request from monopolizing GPU
- Simple to implement and verify

Implementation:
--------------

1. Add to Request structure:
   -------------------------
   typedef struct Request {
       // ... existing fields ...
       time_t wait_start;      // When request entered queue
       uint32_t effective_priority;  // Current priority (may age)
       uint32_t time_quantum;   // Max execution time (ms)
       uint32_t time_used;      // Time already used (ms)
   } Request;

2. Priority Aging Logic:
   ---------------------
   - Low priority (0) ‚Üí Medium (1) after 30 seconds wait
   - Medium priority (1) ‚Üí High (2) after 60 seconds wait
   - High priority (2) ‚Üí Stays high (no aging needed)

3. Time-Slice Quantum:
   -------------------
   - Each request gets maximum execution time (e.g., 5 seconds)
   - After quantum expires, preempt and reschedule
   - Preempted request goes back to queue with remaining time

4. Fairness Tracking:
   ------------------
   - Track per-VM execution time
   - Track per-VM wait time
   - Log statistics for verification

Advantages:
----------
‚úÖ Prevents starvation (low priority eventually executes)
‚úÖ Simple to understand and verify
‚úÖ Deterministic (aging based on time, not events)
‚úÖ Minimal code changes to existing system
‚úÖ Easy to test (can simulate aging)

Disadvantages:
--------------
‚ùå Low priority may wait up to 30 seconds
‚ùå Preemption requires CUDA context save/restore (overhead)
‚ùå Time quantum selection needs tuning

Code Changes Required:
---------------------
- Modify Request structure (add 4 fields)
- Modify insert_request() to set wait_start
- Add aging check in pop_request()
- Add time tracking in process_pool()
- Add preemption logic (future)

Estimated Effort: 2-3 days
Verification: Easy (test with long-running high-priority requests)

================================================================================
                    RECOMMENDATION 2: WEIGHTED FAIR QUEUING (WFQ)
                    Alternative: Better Fairness
================================================================================

Algorithm: Weighted Fair Queuing
--------------------------------

Concept:
--------
- Each priority level gets weight (High=3, Medium=2, Low=1)
- Virtual finish time calculated: finish_time = start_time + (size / weight)
- Requests scheduled by smallest finish_time
- Ensures proportional fairness

Implementation:
--------------

1. Add to Request structure:
   -------------------------
   typedef struct Request {
       // ... existing fields ...
       double virtual_finish_time;  // WFQ finish time
       uint32_t weight;            // Priority weight (2, 1, 0)
   } Request;

2. WFQ Calculation:
   ----------------
   - Weight: High=3, Medium=2, Low=1
   - Virtual finish time = current_time + (estimated_time / weight)
   - Sort by virtual_finish_time instead of priority

3. Fairness Guarantee:
   -------------------
   - High priority gets 3x more resources than low
   - But low priority still gets guaranteed share
   - No starvation possible

Advantages:
----------
‚úÖ Strong fairness guarantees
‚úÖ Proportional resource allocation
‚úÖ Well-studied algorithm (many papers)
‚úÖ Prevents monopolization

Disadvantages:
--------------
‚ùå More complex to implement
‚ùå Requires estimated execution time
‚ùå Virtual time calculation overhead
‚ùå Harder to verify correctness

Code Changes Required:
---------------------
- Modify Request structure
- Rewrite insert_request() with WFQ logic
- Add weight calculation
- Add virtual time tracking

Estimated Effort: 5-7 days
Verification: Moderate (need fairness metrics)

================================================================================
                    RECOMMENDATION 3: ROUND-ROBIN WITH PRIORITY BANDS
                    Alternative: Simplest Approach
================================================================================

Algorithm: Priority Bands with Round-Robin
------------------------------------------

Concept:
--------
- Process all high-priority requests first
- Then all medium-priority
- Then all low-priority
- Within each priority, round-robin between VMs
- Simple deterministic order

Implementation:
--------------

1. Processing Order:
   ----------------
   - Process one request from each high-priority VM (round-robin)
   - Then one from each medium-priority VM
   - Then one from each low-priority VM
   - Repeat cycle

2. Per-VM Round-Robin:
   ------------------
   - Track last processed VM per priority level
   - Next request from different VM in same priority
   - Prevents single VM monopolizing

Advantages:
----------
‚úÖ Very simple to implement
‚úÖ Deterministic
‚úÖ Prevents single-VM monopolization
‚úÖ Easy to verify

Disadvantages:
--------------
‚ùå Low priority can still wait if high priority keeps arriving
‚ùå No aging mechanism
‚ùå Less fair than WFQ

Code Changes Required:
---------------------
- Add per-priority VM tracking
- Modify process_pool() to select by VM round-robin
- Add VM selection logic

Estimated Effort: 1-2 days
Verification: Easy

================================================================================
                    RECOMMENDATION 4: DEFICIT ROUND-ROBIN (DRR)
                    Alternative: Good Balance
================================================================================

Algorithm: Deficit Round-Robin
------------------------------

Concept:
--------
- Each priority level has quantum (credits)
- Process requests until quantum exhausted
- Remaining credits carry over to next round
- Ensures fair service over time

Implementation:
--------------

1. Add to PoolQueue:
   ----------------
   typedef struct {
       // ... existing fields ...
       uint32_t deficit[3];  // Deficit per priority [low, med, high]
       uint32_t quantum[3];  // Quantum per priority
   } PoolQueue;

2. DRR Logic:
   ----------
   - High priority: quantum = 100, deficit starts at 100
   - Medium priority: quantum = 50, deficit starts at 50
   - Low priority: quantum = 25, deficit starts at 25
   - Process requests until deficit exhausted
   - Add quantum to deficit each round

Advantages:
----------
‚úÖ Good fairness guarantees
‚úÖ Prevents starvation
‚úÖ Moderate complexity
‚úÖ Well-understood algorithm

Disadvantages:
--------------
‚ùå More complex than priority aging
‚ùå Quantum selection needs tuning
‚ùå Requires per-priority tracking

Code Changes Required:
---------------------
- Modify PoolQueue structure
- Add DRR logic to process_pool()
- Add deficit tracking

Estimated Effort: 3-4 days
Verification: Moderate

================================================================================
                            COMPARISON MATRIX
================================================================================

Algorithm          | Complexity | Fairness | Starvation | Verifiability | Effort
-------------------|------------|----------|------------|---------------|--------
Priority Aging     | Low        | Good     | Prevents   | Easy          | 2-3 days
WFQ                | High       | Excellent| Prevents   | Moderate      | 5-7 days
Round-Robin Bands  | Very Low   | Fair     | Possible   | Easy          | 1-2 days
DRR                | Medium     | Good     | Prevents   | Moderate      | 3-4 days

================================================================================
                        FINAL RECOMMENDATION
================================================================================

RECOMMENDED: Priority Aging with Time-Slice Quantum
----------------------------------------------------

Rationale:
----------
1. **Fits Current System**: Minimal changes to existing code
2. **Addresses Requirements**: 
   - ‚úÖ Higher priority first (maintained)
   - ‚úÖ No monopolization (time quantum + aging)
   - ‚úÖ Deterministic (time-based, predictable)
   - ‚úÖ Simple (easy to understand and verify)
3. **Extensible**: Foundation for preemption, time limits
4. **Verifiable**: Easy to test and validate
5. **Proven**: Similar to OS scheduling (Linux CFS aging)

Implementation Phases:
---------------------

Phase 1: Priority Aging (Week 1)
- Add wait_start and effective_priority to Request
- Implement aging logic in pop_request()
- Test: Verify low priority ages to medium after 30s

Phase 2: Time-Slice Quantum (Week 2)
- Add time_quantum and time_used to Request
- Add time tracking in process_pool()
- Test: Verify requests preempt after quantum

Phase 3: Fairness Metrics (Week 3)
- Add per-VM statistics tracking
- Add fairness reporting
- Test: Verify no VM monopolizes

Future Extensions:
-----------------
- Preemption with CUDA context save/restore
- Dynamic quantum adjustment
- Advanced policies (deadline scheduling, etc.)

================================================================================
                        IMPLEMENTATION ROADMAP
================================================================================

Week 1: Priority Aging
----------------------
Day 1-2: Modify Request structure, add aging logic
Day 3-4: Implement aging in pop_request()
Day 5: Testing and verification

Week 2: Time-Slice Quantum
---------------------------
Day 1-2: Add time tracking to Request
Day 3-4: Implement quantum enforcement
Day 5: Testing with various quantum values

Week 3: Fairness Metrics
-------------------------
Day 1-2: Add statistics tracking
Day 3-4: Implement fairness reporting
Day 5: Validation and documentation

================================================================================
                        VERIFICATION STRATEGY
================================================================================

Test Cases:
-----------

1. Starvation Prevention:
   - Send continuous high-priority requests
   - Verify low-priority request ages and executes
   - Measure maximum wait time

2. Time Quantum:
   - Send long-running request
   - Verify preemption after quantum expires
   - Verify request resumes correctly

3. Fairness:
   - Send equal requests from multiple VMs
   - Verify fair resource allocation
   - Measure per-VM execution time

4. Determinism:
   - Send same request sequence multiple times
   - Verify identical processing order
   - Verify reproducible behavior

Metrics to Track:
----------------
- Per-VM wait time
- Per-VM execution time
- Priority aging events
- Preemption count
- Fairness ratio (execution_time / wait_time)

================================================================================
                        RISK ASSESSMENT
================================================================================

Low Risk:
---------
‚úÖ Priority aging implementation
‚úÖ Time tracking
‚úÖ Statistics collection

Medium Risk:
------------
‚ö†Ô∏è Time quantum tuning (may need iteration)
‚ö†Ô∏è Performance overhead (minimal expected)

High Risk (Future):
------------------
üî¥ CUDA context preemption (requires careful implementation)
üî¥ Context save/restore overhead

Mitigation:
-----------
- Start with non-preemptive (current approach)
- Add preemption later when needed
- Measure overhead before optimizing

================================================================================
                        NEXT STEPS
================================================================================

1. Review and discuss recommendations
2. Select algorithm (recommend Priority Aging)
3. Create detailed implementation plan
4. Begin Phase 1 implementation
5. Iterate based on testing results

================================================================================
End of Scheduler Recommendations
================================================================================
