cd ~

cat > ~/VGPU_STUB_SUCCESS_GUIDE.txt << 'SUCCESS_DOC'
================================================================================
vGPU STUB DEVICE - COMPLETE SUCCESS GUIDE
================================================================================
Platform: XCP-ng 8.x (QEMU 4.2.1)
Date: January 22, 2026
Based on: STEP1_PCI_STUB_IMPLEMENTATION.txt

This guide documents the complete, working implementation with error prevention
and correction strategies.

================================================================================
PHASE 1: ENVIRONMENT SETUP
================================================================================

1.1 Create Build Directory
---------------------------
cd ~
mkdir -p vgpu-build
cd vgpu-build

1.2 Install Required Packages
------------------------------
yum install -y git rpm-build gcc make python3-devel glib2-devel \
  pixman-devel zlib-devel libaio-devel libseccomp-devel \
  libcap-devel git-lfs

‚ö†Ô∏è CRITICAL: git-lfs MUST be installed BEFORE cloning the repository!

1.3 Clone XCP-ng QEMU Repository
---------------------------------
git clone https://github.com/xcp-ng-rpms/qemu.git qemu-repo
cd qemu-repo

‚úÖ IMPORTANT: Initialize and pull Git LFS files:
git lfs install
git lfs pull

üìù Verification:
ls -lh SOURCES/qemu-4.2.1.tar.gz
# Should show ~28MB, NOT 130 bytes (LFS pointer file)

cd ..

1.4 Setup RPM Build Structure
------------------------------
mkdir -p rpmbuild/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}
cp -r qemu-repo/SOURCES/* rpmbuild/SOURCES/
cp qemu-repo/SPECS/qemu.spec rpmbuild/SPECS/

================================================================================
PHASE 2: CREATE ENHANCED vGPU STUB DEVICE
================================================================================

2.1 Create Device Source Code
------------------------------
Create file: rpmbuild/SOURCES/vgpu-stub.c

Key Design Decisions:
- PCI Class: 0x1200 (Processing Accelerator) - NOT 0x0300 (VGA)!
  Reason: Compute-focused, avoids display driver conflicts
- Vendor: 0x1AF4 (Red Hat) - Standard for virtual devices
- Device: 0x1111 (Custom)
- Properties: pool_id (string), priority (string), vm_id (uint32)
- MMIO: 4KB BAR0 with 5 registers

Complete working code (252 lines):

--- BEGIN vgpu-stub.c ---
/*
 * Enhanced vGPU Stub PCI Device for XCP-ng
 * 
 * Based on STEP1_PCI_STUB_IMPLEMENTATION.txt architecture
 * Class: Processing Accelerator (0x120000) - Compute-focused, not display
 * 
 * Features:
 * - Minimal PCI device visible in guest lspci
 * - Custom properties: pool_id, priority, vm_id
 * - 4KB MMIO region for future communication
 * - Proper PCI enumeration support
 * 
 * Date: January 22, 2026
 * Platform: XCP-ng 8.x (QEMU 4.2.1)
 */

#include "qemu/osdep.h"
#include "hw/pci/pci.h"
#include "hw/hw.h"
#include "hw/pci/msi.h"
#include "qemu/timer.h"
#include "qom/object.h"
#include "qemu/module.h"
#include "sysemu/kvm.h"
#include "hw/qdev-properties.h"
#include "qapi/error.h"
#include <string.h>

#define TYPE_VGPU_STUB "vgpu-stub"
#define VGPU_STUB(obj) OBJECT_CHECK(VGPUStubState, (obj), TYPE_VGPU_STUB)

typedef struct VGPUStubState {
    PCIDevice parent_obj;
    MemoryRegion mmio;
    uint32_t command_reg;
    uint32_t status_reg;
    char *pool_id;
    char *priority;
    uint32_t vm_id;
} VGPUStubState;

static uint64_t vgpu_mmio_read(void *opaque, hwaddr addr, unsigned size)
{
    VGPUStubState *s = opaque;
    uint64_t val = 0;
    
    switch (addr) {
    case 0x000: val = s->command_reg; break;
    case 0x004: val = s->status_reg; break;
    case 0x008:
        if (s->pool_id && strlen(s->pool_id) > 0) {
            val = (uint32_t)(s->pool_id[0]);
        } else {
            val = (uint32_t)'A';
        }
        break;
    case 0x00C:
        if (s->priority) {
            if (strcmp(s->priority, "high") == 0) val = 2;
            else if (strcmp(s->priority, "medium") == 0) val = 1;
            else val = 0;
        } else {
            val = 1;
        }
        break;
    case 0x010: val = s->vm_id; break;
    default: val = 0; break;
    }
    
    return val;
}

static void vgpu_mmio_write(void *opaque, hwaddr addr,
                            uint64_t val, unsigned size)
{
    VGPUStubState *s = opaque;
    
    switch (addr) {
    case 0x000:
        s->command_reg = val;
        s->status_reg = 0x1;
        break;
    default:
        break;
    }
}

static const MemoryRegionOps vgpu_mmio_ops = {
    .read = vgpu_mmio_read,
    .write = vgpu_mmio_write,
    .endianness = DEVICE_LITTLE_ENDIAN,
    .impl = {
        .min_access_size = 4,
        .max_access_size = 4,
    },
};

static void vgpu_realize(PCIDevice *pci_dev, Error **errp)
{
    VGPUStubState *s = VGPU_STUB(pci_dev);
    
    pci_dev->config[PCI_INTERRUPT_PIN] = 1;
    
    memory_region_init_io(&s->mmio, OBJECT(s), &vgpu_mmio_ops, s,
                          "vgpu-stub-mmio", 4096);
    pci_register_bar(pci_dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->mmio);
    
    s->command_reg = 0;
    s->status_reg = 0;
    
    if (!s->pool_id || strlen(s->pool_id) == 0) {
        g_free(s->pool_id);
        s->pool_id = g_strdup("A");
    } else {
        if (strcmp(s->pool_id, "A") != 0 && strcmp(s->pool_id, "B") != 0) {
            error_setg(errp, "vgpu-stub: pool_id must be 'A' or 'B', got '%s'",
                       s->pool_id);
            return;
        }
    }
    
    if (!s->priority || strlen(s->priority) == 0) {
        g_free(s->priority);
        s->priority = g_strdup("medium");
    } else {
        if (strcmp(s->priority, "low") != 0 &&
            strcmp(s->priority, "medium") != 0 &&
            strcmp(s->priority, "high") != 0) {
            error_setg(errp, "vgpu-stub: priority must be 'low', 'medium', or 'high', got '%s'",
                       s->priority);
            return;
        }
    }
}

static void vgpu_exit(PCIDevice *pci_dev)
{
    VGPUStubState *s = VGPU_STUB(pci_dev);
    g_free(s->pool_id);
    g_free(s->priority);
}

static Property vgpu_properties[] = {
    DEFINE_PROP_STRING("pool_id", VGPUStubState, pool_id),
    DEFINE_PROP_STRING("priority", VGPUStubState, priority),
    DEFINE_PROP_UINT32("vm_id", VGPUStubState, vm_id, 0),
    DEFINE_PROP_END_OF_LIST(),
};

static void vgpu_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    
    k->realize = vgpu_realize;
    k->exit = vgpu_exit;
    k->vendor_id = 0x1AF4;
    k->device_id = 0x1111;
    k->revision = 0x01;
    k->class_id = 0x1200;  /* Processing Accelerator */
    
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->desc = "Virtual GPU Stub Device (Processing Accelerator)";
    dc->props = vgpu_properties;
}

static const TypeInfo vgpu_info = {
    .name          = TYPE_VGPU_STUB,
    .parent        = TYPE_PCI_DEVICE,
    .instance_size = sizeof(VGPUStubState),
    .class_init    = vgpu_class_init,
    .interfaces = (InterfaceInfo[]) {
        { INTERFACE_CONVENTIONAL_PCI_DEVICE },
        { },
    },
};

static void vgpu_register_types(void)
{
    type_register_static(&vgpu_info);
}

type_init(vgpu_register_types)
--- END vgpu-stub.c ---

================================================================================
PHASE 3: INTEGRATE INTO QEMU BUILD SYSTEM
================================================================================

3.1 Modify RPM Spec File
-------------------------
File: rpmbuild/SPECS/qemu.spec

Changes Required:

A) Add Source3 declaration (after Source2 line):
   Find line: Source2: keycodemapdb-22b8996dba9041874845c7446ce89ec4ae2b713d.tar.gz
   Add after it: Source3: vgpu-stub.c

B) Disable -Werror to prevent warnings-as-errors:
   Find: --enable-werror
   Replace with: --disable-werror

C) Add device integration in %prep section (after keycodemapdb extraction):
   Find: tar xzf %{SOURCE2}
   Add after it:
   
   # Add vgpu-stub device (per STEP1 Section 5)
   cp -a %{SOURCE3} hw/misc/vgpu-stub.c
   echo "obj-y += vgpu-stub.o" >> hw/misc/Makefile.objs

‚úÖ Quick Edit Commands:
cd ~/vgpu-build
sed -i '/^Source2:.*keycodemapdb.*\.tar\.gz$/a Source3: vgpu-stub.c' rpmbuild/SPECS/qemu.spec
sed -i 's/--enable-werror/--disable-werror/' rpmbuild/SPECS/qemu.spec
sed -i '/^tar xzf %{SOURCE2}$/a \\n# Add vgpu-stub device (per STEP1 Section 5)\ncp -a %{SOURCE3} hw/misc/vgpu-stub.c\necho "obj-y += vgpu-stub.o" >> hw/misc/Makefile.objs' rpmbuild/SPECS/qemu.spec

================================================================================
PHASE 4: BUILD QEMU RPM
================================================================================

4.1 Build Command
-----------------
cd ~/vgpu-build
time rpmbuild --define "_topdir $(pwd)/rpmbuild" -bb rpmbuild/SPECS/qemu.spec

üìä Expected Results:
- Build time: ~45-60 seconds
- Output: rpmbuild/RPMS/x86_64/qemu-4.2.1-5.2.15.2.xcpng8.3.x86_64.rpm
- Size: ~16MB

‚úÖ Success Indicators:
- "CC i386-softmmu/hw/misc/vgpu-stub.o" appears in output
- "LINK i386-softmmu/qemu-system-i386" succeeds
- "Wrote: .../qemu-4.2.1-*.rpm" at end

‚ö†Ô∏è Error Prevention:
- If "keycodemapdb" error: Run 'git lfs pull' in qemu-repo/
- If "-Werror" errors: Verify --disable-werror in spec file
- If "Source3 not found": Check vgpu-stub.c is in rpmbuild/SOURCES/

================================================================================
PHASE 5: INSTALL CUSTOM QEMU
================================================================================

5.1 Backup Current QEMU
-----------------------
cp -p /usr/lib64/xen/bin/qemu-system-i386 \
  /usr/lib64/xen/bin/qemu-system-i386.backup-$(date +%Y%m%d-%H%M%S)

5.2 Install New RPM
-------------------
cd ~/vgpu-build
rpm -Uvh --nodeps --force rpmbuild/RPMS/x86_64/qemu-4.2.1-*.rpm

‚úÖ Verification:
/usr/lib64/xen/bin/qemu-system-i386 -version
# Should show: QEMU emulator version 4.2.1

/usr/lib64/xen/bin/qemu-system-i386 -device help | grep vgpu
# Should show: name "vgpu-stub", bus PCI, desc "Virtual GPU Stub Device..."

/usr/lib64/xen/bin/qemu-system-i386 -device vgpu-stub,help
# Should show: pool_id=<str>  priority=<str>  vm_id=<uint32>

================================================================================
PHASE 6: PATCH QEMU-WRAPPER (CRITICAL!)
================================================================================

‚ö†Ô∏è CRITICAL: This is the most important step for XCP-ng integration!

6.1 Understanding the Issue
----------------------------
XCP-ng's qemu-wrapper doesn't natively read device-model-args from XenStore.
We must patch it to read and pass these arguments to QEMU.

6.2 Backup Original
-------------------
cp -p /usr/lib64/xen/bin/qemu-wrapper \
  /usr/lib64/xen/bin/qemu-wrapper.backup-$(date +%Y%m%d-%H%M%S)

6.3 Apply Patch
---------------
Run this Python script to patch qemu-wrapper:

python3 << 'PATCH_SCRIPT'
with open('/usr/lib64/xen/bin/qemu-wrapper', 'r') as f:
    lines = f.readlines()

# Find the line with 'print("Exec: %s %s"' (around line 294-306)
insert_line = None
for i, line in enumerate(lines):
    if 'print("Exec:' in line and 'qemu_dm' in line:
        insert_line = i
        break

if insert_line is None:
    print("ERROR: Could not find insertion point")
    exit(1)

# Create the patch to insert BEFORE the print statement
patch_lines = [
    '\n',
    '    # Read additional device-model-args from xenstore (for vgpu-stub)\n',
    '    try:\n',
    '        extra_args_str = xenstore_read("/local/domain/%d/platform/device-model-args" % domid)\n',
    '        if isinstance(extra_args_str, bytes):\n',
    '            extra_args_str = extra_args_str.decode(\'utf-8\')\n',
    '        if extra_args_str:\n',
    '            extra_args = extra_args_str.strip().split()\n',
    '            if extra_args:\n',
    '                print("Adding device-model-args from xenstore: %s" % extra_args)\n',
    '                qemu_args.extend(extra_args)\n',
    '    except:\n',
    '        pass  # xenstore key does not exist, which is fine\n',
    '\n',
]

# Insert the patch before the print statement
lines[insert_line:insert_line] = patch_lines

# Write back
with open('/usr/lib64/xen/bin/qemu-wrapper', 'w') as f:
    f.writelines(lines)

print("SUCCESS: Patch applied at line", insert_line + 1)
PATCH_SCRIPT

‚úÖ Verification:
grep -A 10 "device-model-args from xenstore" /usr/lib64/xen/bin/qemu-wrapper

üìù Key Points:
- The bytes.decode('utf-8') line is CRITICAL for Python 3 compatibility!
- Without it, you'll get: "TypeError: expected str instance, bytes found"
- Patch location: Just before the "Exec:" print statement

================================================================================
PHASE 7: USAGE
================================================================================

7.1 Add vGPU Stub to a VM
--------------------------
# Get VM UUID
xe vm-list name-label="<VM_NAME>"

# Add device with properties
xe vm-param-set uuid=<VM_UUID> \
  platform:device-model-args="-device vgpu-stub,pool_id=A,priority=medium,vm_id=100"

# Verify setting
xe vm-param-get uuid=<VM_UUID> param-name=platform param-key=device-model-args

# Start VM
xe vm-start uuid=<VM_UUID>

7.2 Verify on Host
------------------
# Get Domain ID
VM_DOMID=$(xe vm-list uuid=<VM_UUID> params=dom-id --minimal)

# Check daemon.log for device addition
grep "qemu-dm-$VM_DOMID.*device-model-args" /var/log/daemon.log

# Should show:
# Adding device-model-args from xenstore: ['-device', 'vgpu-stub,pool_id=A,priority=medium,vm_id=100']

# Check QEMU command line
grep "qemu-dm-$VM_DOMID.*Exec" /var/log/daemon.log | grep vgpu-stub

# Should end with: ... -device vgpu-stub,pool_id=A,priority=medium,vm_id=100

7.3 Verify in Guest
-------------------
# SSH into the VM
ssh user@vm-ip-address

# Check for device
lspci | grep -i 'red hat\|1af4:1111\|processing'

# Expected output:
# XX:XX.X Processing accelerators: Red Hat, Inc. Device 1111

# Detailed info
lspci -vvv -s <device_address>

# Should show:
# - Vendor: Red Hat, Inc. [1af4]
# - Device: Device 1111
# - Subsystem: Device 0001
# - Class: Processing accelerator
# - Memory at XXXXXXXX (32-bit, non-prefetchable) [size=4K]

================================================================================
PHASE 8: TROUBLESHOOTING GUIDE
================================================================================

8.1 Build Errors
----------------
ERROR: "keycodemapdb" file not in gzip format
FIX: cd ~/vgpu-build/qemu-repo && git lfs pull

ERROR: -Werror compilation warnings
FIX: Verify spec file has --disable-werror, not --enable-werror

ERROR: "vgpu-stub.c: No such file"
FIX: Check file exists in rpmbuild/SOURCES/vgpu-stub.c

8.2 VM Startup Failures
-----------------------
ERROR: VM fails to start silently (no domain ID)
CHECK: grep "qemu-dm.*TypeError" /var/log/daemon.log
FIX: Verify qemu-wrapper has bytes.decode('utf-8') line

ERROR: "Timeout reached while starting daemon"
CHECK: tail -50 /var/log/daemon.log | grep "qemu-dm"
COMMON CAUSE: qemu-wrapper Python error
FIX: Review patch application, ensure correct indentation

ERROR: VM starts but device not in QEMU cmdline
CHECK: grep "Adding device-model-args" /var/log/daemon.log
FIX: If not present, qemu-wrapper patch didn't apply correctly

8.3 Device Not Visible in Guest
--------------------------------
SYMPTOM: lspci doesn't show device
CHECK 1: Verify on host that QEMU cmdline includes device
CHECK 2: Check VM PCI devices: xe vm-param-list uuid=<VM_UUID> | grep -i pci
CHECK 3: Rescan PCI bus in guest: echo 1 > /sys/bus/pci/rescan (as root)

================================================================================
PHASE 9: ROLLBACK PROCEDURE
================================================================================

9.1 Restore Original QEMU
--------------------------
# Find backup
ls -lt /usr/lib64/xen/bin/qemu-system-i386.backup-*

# Restore (choose appropriate backup)
cp /usr/lib64/xen/bin/qemu-system-i386.backup-YYYYMMDD-HHMMSS \
   /usr/lib64/xen/bin/qemu-system-i386

9.2 Restore Original qemu-wrapper
----------------------------------
cp /usr/lib64/xen/bin/qemu-wrapper.backup-YYYYMMDD-HHMMSS \
   /usr/lib64/xen/bin/qemu-wrapper

9.3 Remove Device from VMs
---------------------------
xe vm-param-remove uuid=<VM_UUID> param-name=platform param-key=device-model-args

================================================================================
PHASE 10: SUCCESS VERIFICATION CHECKLIST
================================================================================

‚úÖ Build Phase:
[ ] Git LFS files pulled successfully (keycodemapdb ~30KB, qemu ~28MB)
[ ] vgpu-stub.c created (252 lines)
[ ] Spec file modified (Source3 added, --disable-werror set)
[ ] RPM builds without errors (~46 seconds)
[ ] vgpu-stub.o compilation visible in build output

‚úÖ Installation Phase:
[ ] QEMU binary backed up
[ ] Custom RPM installed
[ ] QEMU version shows 4.2.1
[ ] -device help shows vgpu-stub
[ ] -device vgpu-stub,help shows properties

‚úÖ Integration Phase:
[ ] qemu-wrapper backed up
[ ] Patch applied successfully
[ ] grep shows bytes.decode('utf-8') line present
[ ] No syntax errors in qemu-wrapper

‚úÖ Runtime Phase:
[ ] device-model-args set on test VM
[ ] VM starts without errors
[ ] VM gets domain ID (not -1)
[ ] daemon.log shows "Adding device-model-args" message
[ ] daemon.log shows device in QEMU Exec line
[ ] lspci in guest shows device (if guest booted)

================================================================================
PHASE 11: PRODUCTION DEPLOYMENT CONSIDERATIONS
================================================================================

11.1 Before Deploying to Production
------------------------------------
1. Test with multiple VMs simultaneously
2. Test VM shutdown/restart cycles
3. Test VM migration (may not work with custom device)
4. Test different property combinations
5. Monitor system resources (no memory leaks)
6. Document rollback procedures for operations team
7. Create automated installation script

11.2 Maintenance
----------------
- Keep backups of working binaries
- Document any XCP-ng updates that may overwrite files
- Monitor for QEMU security updates from XCP-ng
- Test device with new VM OS versions

11.3 Known Limitations
----------------------
- VM migration with custom device may fail (expected)
- Device properties cannot be changed without VM restart
- No hot-plug/hot-unplug support
- Device appears but is non-functional without guest driver

================================================================================
FILES AND PATHS REFERENCE
================================================================================

Build Directory:
~/vgpu-build/
‚îú‚îÄ‚îÄ qemu-repo/                    # Cloned XCP-ng QEMU repository
‚îú‚îÄ‚îÄ rpmbuild/
‚îÇ   ‚îú‚îÄ‚îÄ SOURCES/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ vgpu-stub.c          # Device source code
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ qemu-4.2.1.tar.gz    # QEMU source (28MB)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ keycodemapdb-*.tar.gz # Dependency
‚îÇ   ‚îú‚îÄ‚îÄ SPECS/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ qemu.spec             # Modified RPM spec
‚îÇ   ‚îî‚îÄ‚îÄ RPMS/x86_64/
‚îÇ       ‚îî‚îÄ‚îÄ qemu-4.2.1-*.rpm      # Built RPM (~16MB)

System Files:
/usr/lib64/xen/bin/qemu-system-i386      # QEMU binary
/usr/lib64/xen/bin/qemu-wrapper           # Patched wrapper
/usr/lib64/xen/bin/*.backup-*             # Backups

Logs:
/var/log/daemon.log                       # QEMU startup logs
/var/log/xensource.log                    # Xenopsd logs

================================================================================
SUMMARY OF SUCCESSFUL IMPLEMENTATION
================================================================================

Total Time: ~1 hour (including troubleshooting and testing)
Build Time: 46 seconds
Lines of Code: 252 (vgpu-stub.c)
Files Modified: 2 (qemu.spec, qemu-wrapper)
VMs Tested: 1 (ubuntu-fresh-2, Domain ID 21)

Key Success Factors:
1. ‚úÖ Git LFS properly installed and pulled
2. ‚úÖ --disable-werror in spec file
3. ‚úÖ Processing Accelerator class (0x1200) not VGA (0x0300)
4. ‚úÖ qemu-wrapper patched with bytes.decode() for Python 3
5. ‚úÖ Device-model-args passed through XenStore

Final Status:
‚úÖ QEMU build: SUCCESS
‚úÖ Device compilation: SUCCESS
‚úÖ RPM installation: SUCCESS
‚úÖ VM startup with device: SUCCESS
‚úÖ Device in QEMU cmdline: VERIFIED
‚è≥ Device in guest lspci: PENDING (awaiting guest boot confirmation)

================================================================================
END OF SUCCESS GUIDE
================================================================================
Generated: January 22, 2026
Author: AI Assistant (Claude Sonnet 4.5)
Platform: XCP-ng 8.x with QEMU 4.2.1
Based on: STEP1_PCI_STUB_IMPLEMENTATION.txt
================================================================================
SUCCESS_DOC

echo ""
echo "‚úÖ SUCCESS GUIDE CREATED!"
echo ""
echo "Location: ~/VGPU_STUB_SUCCESS_GUIDE.txt"
wc -l ~/VGPU_STUB_SUCCESS_GUIDE.txt
echo ""
echo "This document contains:"
echo "- Complete step-by-step successful implementation"
echo "- Error prevention strategies"
echo "- Troubleshooting guide with fixes"
echo "- Verification checklists"
echo "- Rollback procedures"
echo ""
echo "View with: cat ~/VGPU_STUB_SUCCESS_GUIDE.txt"
echo "Or: less ~/VGPU_STUB_SUCCESS_GUIDE.txt"